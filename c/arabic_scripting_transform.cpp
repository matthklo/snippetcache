#include <set>

//====== Arabic handscript transform

//
// Arabic un-transformed code point range: 0x0600 ~ 0x06FF, 0x0750 ~ 0x077F
// https://zh.wikipedia.org/wiki/%E9%98%BF%E6%8B%89%E4%BC%AF%E5%AD%97%E6%AF%8D
//
// Code points which need to apply transform: 0x0621 ~ 0x064a
// http://blog.csdn.net/gaojinshan/article/details/7846461
//

static unsigned int _arabic_possible_leading_ch[] = {
	0x62c,0x62d,0x62e,0x647,0x639,0x63a,0x641,0x642,
	0x62b,0x635,0x636,0x637,0x643,0x645,0x646,0x62a,
	0x644,0x628,0x64a,0x633,0x634,0x638,0x626,0x64b,
	0x64c,0x64d,0x64e,0x64f,0x650,0x651,0x652,0x653,
	0x654,0x655,0x656,0x657,0x658,0x659,0x65a,0x65b,
	0x65c,0x65d,0x65e,0x65f };

static unsigned int _arabic_possible_tailing_ch[] = {
	0x62c,0x62d,0x62e,0x647,0x639,0x63a,0x641,0x642,
	0x62b,0x635,0x636,0x637,0x643,0x645,0x646,0x62a,
	0x644,0x628,0x64a,0x633,0x634,0x638,0x626,0x627,
	0x623,0x625,0x622,0x62f,0x630,0x631,0x632,0x648,
	0x624,0x629,0x649,0x64b,0x64c,0x64d,0x64e,0x64f,
	0x650,0x651,0x652,0x653,0x654,0x655,0x656,0x657,
	0x658,0x659,0x65a,0x65b,0x65c,0x65d,0x65e,0x65f };

// Transform Map for 0x0621 ~ 0x064a: {last, first, middle, alone}
static unsigned int _arabic_transform_map[][4] = {
	{ 0xfe80,0xfe80,0xfe80,0xfe80 }, /*0x0621*/
	{ 0xfe81,0xfe82,0xfe82,0xfe81 },
	{ 0xfe83,0xfe84,0xfe84,0xfe83 },
	{ 0xfe85,0xfe86,0xfe86,0xfe85 },
	{ 0xfe87,0xfe88,0xfe88,0xfe87 },
	{ 0xfe89,0xfe8a,0xfe8c,0xfe8b }, /*0x0626*/
	{ 0xfe8d,0xfe8e,0xfe8e,0xfe8d },
	{ 0xfe8f,0xfe90,0xfe92,0xfe91 },
	{ 0xfe93,0xfe94,0xfe93,0xfe93 },
	{ 0xfe95,0xfe96,0xfe98,0xfe97 }, /*0x062a*/
	{ 0xfe99,0xfe9a,0xfe9c,0xfe9b },
	{ 0xfe9d,0xfe9e,0xfea0,0xfe9f },
	{ 0xfea1,0xfea2,0xfea4,0xfea3 },
	{ 0xfea5,0xfea6,0xfea8,0xfea7 },
	{ 0xfea9,0xfeaa,0xfeaa,0xfea9 },
	{ 0xfeab,0xfeac,0xfeac,0xfeab }, /*0x0630*/
	{ 0xfead,0xfeae,0xfeae,0xfead },
	{ 0xfeaf,0xfeb0,0xfeb0,0xfeaf },
	{ 0xfeb1,0xfeb2,0xfeb4,0xfeb3 },
	{ 0xfeb5,0xfeb6,0xfeb8,0xfeb7 },
	{ 0xfeb9,0xfeba,0xfebc,0xfebb }, /*0x0635*/
	{ 0xfebd,0xfebe,0xfec0,0xfebf },
	{ 0xfec1,0xfec2,0xfec4,0xfec3 },
	{ 0xfec5,0xfec6,0xfec8,0xfec7 },
	{ 0xfec9,0xfeca,0xfecc,0xfecb },
	{ 0xfecd,0xfece,0xfed0,0xfecf },
	{ 0x63b,0x63b,0x63b,0x63b }, /* 0x63b ~ 0x640 no need to transform */
	{ 0x63c,0x63c,0x63c,0x63c },
	{ 0x63d,0x63d,0x63d,0x63d },
	{ 0x63e,0x63e,0x63e,0x63e },
	{ 0x63f,0x63f,0x63f,0x63f },
	{ 0x640,0x640,0x640,0x640 }, 
	{ 0xfed1,0xfed2,0xfed4,0xfed3 }, /*0x0641*/
	{ 0xfed5,0xfed6,0xfed8,0xfed7 },
	{ 0xfed9,0xfeda,0xfedc,0xfedb },
	{ 0xfedd,0xfede,0xfee0,0xfedf },
	{ 0xfee1,0xfee2,0xfee4,0xfee3 }, /*0x0645*/
	{ 0xfee5,0xfee6,0xfee8,0xfee7 },
	{ 0xfee9,0xfeea,0xfeec,0xfeeb },
	{ 0xfeed,0xfeee,0xfeee,0xfeed },
	{ 0xfeef,0xfef0,0xfef0,0xfeef },
	{ 0xfef1,0xfef2,0xfef4,0xfef3 } /*0x064a*/
};

static unsigned int _arabic_handscript_transform(unsigned int ch, unsigned int prev, unsigned int next, unsigned int *consumed)
{
	static std::set<unsigned int> conj_prefix;
	static std::set<unsigned int> conj_postfix;

	if (conj_prefix.empty())
	{
		for (unsigned int i = 0; i< (sizeof(_arabic_possible_leading_ch) / sizeof(unsigned int)); ++i)
			conj_prefix.insert(_arabic_possible_leading_ch[i]);
	}

	if (conj_postfix.empty())
	{
		for (unsigned int i = 0; i< (sizeof(_arabic_possible_tailing_ch) / sizeof(unsigned int)); ++i)
			conj_postfix.insert(_arabic_possible_tailing_ch[i]);
	}

	if ((ch < 0x0621) || (ch > 0x064a))
		return ch;

	const unsigned int tidx = (ch - 0x0621); // tidx is the index used in _arabic_transform_map. 
	const bool is_conj_prefix = (conj_prefix.find(prev) != conj_prefix.end());
	const bool is_conj_postfix = (conj_postfix.find(next) != conj_postfix.end());
	if (consumed) *consumed = 0;

	if (ch == 0x0644)
	{
		if (consumed) *consumed = 1;
		switch (next)
		{
		case 0x0622:
			return is_conj_prefix ? 0xfef6 : 0xfef5;
		case 0x0623:
			return is_conj_prefix ? 0xfef8 : 0xfef7;
		case 0x0625:
			return is_conj_prefix ? 0xfefa : 0xfef9;
		case 0x0627:
			return is_conj_prefix ? 0xfefc : 0xfefb;
		default:
			if (consumed) *consumed = 0;
			break;
		}
	}

	if (is_conj_prefix)
	{
		return is_conj_postfix ? _arabic_transform_map[tidx][2] /* middle */ : _arabic_transform_map[tidx][1] /* last */;
	}
	return is_conj_postfix ? _arabic_transform_map[tidx][3] /* beginning */ : _arabic_transform_map[tidx][0] /* isolated */;
}

// Expect an array of UTF-32 characters. 
// Clone the array and apply arabic character transform on the clone.
// Returns the array head of the clone.
unsigned long* transform(unsigned long * codepoints, unsigned int characters)
{
	unsigned long *ncp = new unsigned long[characters+1];
	::memcpy(ncp, codepoints, sizeof(unsigned long)*(characters + 1));

	unsigned int tidx = 0;
	for (unsigned int i = 0; codepoints[i] != 0; ++i)
	{
		unsigned int ch = (unsigned int)codepoints[i];
		unsigned int prev_ch = 0;
		unsigned int next_ch = 0;

		if (i > 0)
			prev_ch = (unsigned int)codepoints[i - 1];
		next_ch = (unsigned int)codepoints[i + 1];

		unsigned int consumed = 0;
		ncp[tidx++] = _arabic_handscript_transform(ch, prev_ch, next_ch, &consumed);
		i += consumed;
	}
	ncp[tidx] = 0;

	return ncp;
}
